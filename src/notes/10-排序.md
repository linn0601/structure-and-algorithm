主角：排序算法

前序
<pre>
常用的排序算法包括：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。

问题1 ：插入排序、冒泡排序和选择排序的时间复杂度都是O（n^2),但是在实际开发中更倾向使用插入排序而不是冒泡排序呢
</pre>

**分析一个排序算法：**

<pre>
1.最好情况、最坏情况、平均情况时间复杂度：
2. 时间复杂度的系数、常数、低阶：时间复杂度反映的是数据规模n很大的时候的一个增长趋势，所以他表示时会忽略系数、常数、低阶等，因此要考虑进来
3.比较和交换的次数

排序算法的内存消耗：算法的内存消耗可以通过空间复杂度来进行衡量，支队排序算法的空间复杂度，又一个新的概念，叫做原地排序。就是指空间复杂度为O(1)的排序
算法，冒泡、插入、选择都是原地排序。

算法排序的稳定性：针对排序算法有一个稳定性的指标，如果带排序的序列中存在值相等的元素，经过排序之后，相等之间元素顺序不变。
</pre>

冒泡排序 Bubble Sort
<pre>
冒泡排序只会操作相邻的两个数据，每次冒泡操作都会对两个相邻数据元素进行比较，看是否满足大小关系，不满足则互换位置，一次冒泡会至少让一个元素移动他他应该
在的位置，重复n次，就完成了n个数据的排序工作。

1.冒泡排序是原地排序算法吗？
冒泡排序的过程只设计相邻的数据交换操作，只需要常量级的临时空间，所以他的空间复杂度为O(1),是一个原地排序算法

2.冒泡排序是稳定的排序算法吗？
在冒泡排序中，只有交换才可以改变两个元素的前后顺序，为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序后不会
改变顺序。

3。冒泡排序的时间复杂度是多少？
最好的情况，要排序的数据已经有序，我们只需要进行一次冒泡操作就可以结束了，所以最好的时间复杂度是O（n），而最坏的情况是数据刚好倒叙，我们需要进行n次冒泡操作
，所以最坏的情况的时间复杂度为O（n^2)

平均时间复杂度分析：对于包含n个数据的数组，这n个数据就有n！种排序方式，不同的排序方式，冒泡排序执行的时间肯定不同的，通过有序度、逆序度这两个概念进行分析。
</pre>

插入排序 Insertion Sort
<pre>
首先将数组中的数据分为两个区间，已排序区间和未排序区间，初始排序区间只有一个元素，就是数组的第一个元素，插入算法的狠心思想是取为排序的区间中的元素，在已排序
区间中的元素找到合适位置将其插入，并保证已排序区间一直有序。重复这个过程，直到为排序区间中元素为null，算法结束。

1.插入排序是原地的排序算法吗？
插入排序运行不需要额外的存储空间，所以空间复杂度是O（1）是一个原地排序算法。

2.插入排序是稳定的排序算法吗？
在插入排序中，独具值相同的元素，我们可以选择将后面出现的元素插入到前面出现的元素，这样就可以保持原有的前后顺序不变。插入元素是稳定的排序算法

3.插入排序的时间复杂度是多少？
如果要排序的数据已经有序，我们并不需要搬移任何数据，如果我们从头到尾都在有序的组织里面查找位置，每次只需要比较一个数据就能确定插入的位置，这种情况最好的时间
复杂度是O（n）

如果是倒序的，最坏时间复杂度是O(n^2)

在数组中插入一个数据的平均复杂度是O(n)，对于插入排序来说，每次插入操作都相当于在数组中插入一条数据，循环执行n次插入操作，所以平均时间复杂度O（n^2）
</pre>

选择排序（Selection Sort）
<pre>
选择排序的算法实现类似插入排序，也分已排序的区间和为排序的区间，但是选择排序每次都会从未排序区间中找到最小的元素，将其放到已排序区间的末尾

选择排序是一种空间复杂度为O（1）的原地排序算法，选择排序的最好情况下的时间复杂度和平均情况下的时间复杂度为O（n^2），但选择排序并不是稳定排序算法，相比
冒泡、插入略逊色些。冒泡排序和插入排序虽然时间复杂度都是O（n^2），但是插入排序有很大的优化空间。而希尔排序是插入排序的一种改进版本，希尔排序是非稳定的。
</pre>


归并排序 Merge Sort
<pre>
归并排序就是先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合并在一下，这样整个数组都有序了。归并排序使用的就是分治思想，将一个
大问题分解成小的子问题来解决

递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) 
终止条件：
p >= r 不用再继续分解

merge_sort（p...r)，给下标p到r之间数组进行排序，我们将这个排序问题转化成2个子问题 merge（merge_sort(p...q), merge_sort(q+1, r)其中下标q等于p和r的中间
位置，也就是（p+r）/2。当下标从p到q和q+1到r这两个子数组都排序好了只会，再将两个有序子数组合并在一下，这样整个数组也就排好了。

归并排序的时间复杂度任何情况下都是O（n long n) 看起来非常优秀，但是归并排序并没有像快排应用广泛，因为归并排序并不是原地排序。归并排序在合并在合并2个有序数组
是需要借助额外的存储空间。
</pre>

快速排序
<pre>
快排也是利用了分治思想，如果排序的数组下标是p 到 r 之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点），我们遍历p到r之间的数据，将下于pivot的放到左边，
将大雨pivot的放到右边，前面p到q-1之间的都是小雨pivot的，中间是pivot，后面的q+1 到r之间大于pivot的。

快排的时间复杂度是n long n 只有在极端的情况下才退化到O(n^2)
</pre>